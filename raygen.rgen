#version 460
#extension GL_EXT_ray_tracing : require


struct ray
{
	vec4 direction;// = vec3(0.0);
	vec4 origin;// = vec3(0.0);
	bool in_use;// = false;
	int level;// = 0;

	int parent_id;
	vec3 base_color;
	vec3 accumulated_color;
	float reflection_constant;
	float refraction_constant;
	vec3 running_reflected_color;
	vec3 running_refracted_color;
	bool reflected_ray;
};

const int level_cutoff = 10;
const int buffer_size = 128;
ray rays[buffer_size];
int current_buffer_index = 0;


layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 1, set = 0, rgba8) uniform image2D image;
layout(binding = 2, set = 0) uniform CameraProperties 
{
	mat4 viewInverse;
	mat4 projInverse;
	vec4 lightPos;
} cam;


struct RayPayload {
	vec3 color;
	vec3 pure_color;
	float distance;
	vec3 normal;
	float reflector;
	float opacity;
};

layout(location = 0) rayPayloadEXT RayPayload rayPayload;

// Max. number of recursion is passed via a specialization constant
layout (constant_id = 0) const int MAX_RECURSION = 0;

void main() 
{
	const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
	const vec2 inUV = pixelCenter/vec2(gl_LaunchSizeEXT.xy);
	vec2 d = inUV * 2.0 - 1.0;

	vec4 origin = cam.viewInverse * vec4(0,0,0,1);
	vec4 target = cam.projInverse * vec4(d.x, d.y, 1, 1) ;
	vec4 direction = cam.viewInverse*vec4(normalize(target.xyz / target.w), 0);

	uint rayFlags = gl_RayFlagsOpaqueEXT;
	uint cullMask = 0xff;
	float tmin = 0.001;
	float tmax = 10000.0;


	for(int i = 0; i < buffer_size; i++)
	{
		rays[i].direction = vec4(0.0);
		rays[i].origin = vec4(0.0);
		rays[i].in_use = false;
		rays[i].level = 0;
		rays[i].parent_id = -1;
		rays[i].base_color = vec3(0.0);
		rays[i].accumulated_color = vec3(0.0);
		rays[i].reflection_constant = 0;
		rays[i].refraction_constant = 0;
		rays[i].running_reflected_color = vec3(0.0);
		rays[i].running_refracted_color = vec3(0.0);
		rays[i].reflected_ray = false;
	}

	rays[0].direction = direction;
	rays[0].origin = origin;
	rays[0].in_use = true;
	rays[0].level =	1;
	rays[0].parent_id = -1;
	rays[0].reflected_ray = false;
	
	current_buffer_index++;

	traceRayEXT(topLevelAS, rayFlags, cullMask, 0, 0, 0, rays[0].origin.xyz, tmin, rays[0].direction.xyz, tmax, 0);
	vec4 hitPos = rays[0].origin + rays[0].direction * rayPayload.distance;

	// hit the wall
	if(rayPayload.distance == -1.0)
	{
		rays[0].base_color = rayPayload.color;
		rays[0].reflection_constant = rayPayload.reflector;
		rays[0].refraction_constant = rayPayload.opacity;
	}
	else
	{
		// entering
		if(dot(rays[0].direction.xyz, rayPayload.normal) <= 0.0)
		{
			if(current_buffer_index < buffer_size - 1)
			{
				//generate new ray
				rays[current_buffer_index].origin.xyz = hitPos.xyz + rayPayload.normal * 0.01f;
				rays[current_buffer_index].direction.xyz = reflect(rays[0].direction.xyz, rayPayload.normal);
				rays[current_buffer_index].parent_id = 0;
				rays[current_buffer_index].in_use = true;
				rays[current_buffer_index].reflected_ray = true;

				current_buffer_index++;
			}

			if(current_buffer_index < buffer_size - 1)
			{
				//generate new ray
				rays[current_buffer_index].origin.xyz = hitPos.xyz - rayPayload.normal * 0.01f;
				rays[current_buffer_index].direction.xyz = rays[0].direction.xyz;//, rayPayload.normal);
				rays[current_buffer_index].parent_id = 0;
				rays[current_buffer_index].in_use = true;
				rays[current_buffer_index].reflected_ray = false;

				current_buffer_index++;
			}
		}
						// exiting
		else
		{
			if(current_buffer_index < buffer_size - 1)
			{
				//generate new ray
				rays[current_buffer_index].origin.xyz = hitPos.xyz + rayPayload.normal * 0.01f;
				rays[current_buffer_index].direction.xyz = rays[0].direction.xyz;
				rays[current_buffer_index].parent_id = 0;
				rays[current_buffer_index].in_use = true;
				rays[current_buffer_index].reflected_ray = false;

				current_buffer_index++;
			}
		}
	}
	
	rays[0].in_use = false;

	while(true)
	{
		int used_count = 0;

		for(int i = 0; i < buffer_size; i++)
		{
			if(rays[i].in_use)
			{
				used_count++;
				rays[i].base_color = rayPayload.color;
				rays[i].reflection_constant = rayPayload.reflector;
				rays[i].refraction_constant = rayPayload.opacity;

				if(rayPayload.distance == -1.0)
				{
					rays[i].in_use = false;
					continue;
				}

				rays[i].level++;
					
				if(rays[i].level >= level_cutoff)
				{
					rays[i].in_use = false;
					continue;
				}
				
				traceRayEXT(topLevelAS, rayFlags, cullMask, 0, 0, 0, rays[i].origin.xyz, tmin, rays[i].direction.xyz, tmax, 0);
				vec4 hitPos = rays[i].origin + rays[i].direction * rayPayload.distance;
				
				// entering
				if(dot(rays[i].direction.xyz, rayPayload.normal) <= 0.0)
				{
					if(current_buffer_index < buffer_size - 1)
					{
						//generate new ray
						rays[current_buffer_index].origin.xyz = hitPos.xyz + rayPayload.normal * 0.01f;
						rays[current_buffer_index].direction.xyz = reflect(rays[i].direction.xyz, rayPayload.normal);
						rays[current_buffer_index].parent_id = i;
						rays[current_buffer_index].in_use = true;
						rays[current_buffer_index].reflected_ray = true;

						current_buffer_index++;
					}

					if(current_buffer_index < buffer_size - 1)
					{
						//generate new ray
						rays[current_buffer_index].origin.xyz = hitPos.xyz - rayPayload.normal * 0.01f;
						rays[current_buffer_index].direction.xyz = rays[i].direction.xyz;//, rayPayload.normal);
						rays[current_buffer_index].parent_id = i;
						rays[current_buffer_index].in_use = true;
						rays[current_buffer_index].reflected_ray = false;

						current_buffer_index++;
					}	
				}
				// exiting
				else
				{
					if(current_buffer_index < buffer_size - 1)
					{
						//generate new ray
						rays[current_buffer_index].origin.xyz = hitPos.xyz + rayPayload.normal * 0.01f;
						rays[current_buffer_index].direction.xyz = rays[i].direction.xyz;
						rays[current_buffer_index].parent_id = i;
						rays[current_buffer_index].in_use = true;
						rays[current_buffer_index].reflected_ray = false;

						current_buffer_index++;
					}
				}

				rays[i].in_use = false;
			}
		}

		if(used_count == 0)
			break;
	}

	for(int i = current_buffer_index - 1; i > 0; i--)
	{
		

	}






	vec3 color = rays[1].base_color;//mix(rays[0].base_color, rays[0].reflected_color, rays[0].reflection_constant);// + wall_color;//color + wall_color;
	//color = mix(color, refracted_color, 1 - base_opacity);
	
	//color += wall_color;

	imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(color, 0.0));

	return;

	/*
		int free_count = 0;

		for(int i = 0; i < buffer_size; i++)
			if(rays[i].in_use == false)
				free_count++;

		bool branching_allowed = true;

		if(free_count == 0)
			branching_allowed = false;

		int used_count = 0;

		for(int i = 0; i < buffer_size; i++)
		{
			if(rays[i].in_use)
			{
				used_count++;

				traceRayEXT(topLevelAS, rayFlags, cullMask, 0, 0, 0, rays[i].origin.xyz, tmin, rays[i].direction.xyz, tmax, 0);
				const vec4 hitPos = rays[i].origin + rays[i].direction * rayPayload.distance;

				if(rays[i].level == 1)
				{
					rays[i].level++;
					base_color = rayPayload.color;
					base_reflectivity = rayPayload.reflector;
					base_opacity = rayPayload.opacity;
				}
			else
				{
					if(rays[i].reflected_ray == true)
						reflected_color += rayPayload.color;
					else
					{
						vec3 new_origin = hitPos.xyz + rayPayload.normal * 0.01f;
						float dist = distance(rays[i].origin.xyz, new_origin);

						refracted_color += dist*rayPayload.opacity*rayPayload.color;
					}
						
					if(rayPayload.distance == -1.0)
					{
						rays[i].in_use = false;
						//reflected_color = rayPayload.color;
						continue;
					}

					rays[i].level++;
					
					if(rays[i].level >= level_cutoff)
					{
						rays[i].in_use = false;
						continue;
					}
				}

				// entering
				if(dot(rays[i].direction.xyz, rayPayload.normal) <= 0.0)
				{
					rays[i].origin.xyz = hitPos.xyz - rayPayload.normal * 0.01f;
					//rays[i].direction.xyz = reflect(rays[i].direction.xyz, rayPayload.normal);
					rays[i].reflected_ray = false;//true;
				
				}
				// exiting
				else
				{
					rays[i].origin.xyz = hitPos.xyz + rayPayload.normal * 0.01f;
					rays[i].reflected_ray = false;
					//rays[i].direction.xyz = reflect(rays[i].direction.xyz, rayPayload.normal);			
				}
			}
		}

		if(used_count == 0)
			break;
	}

	*/

	/*

	vec3 color = mix(base_color, reflected_color, base_reflectivity);// + wall_color;//color + wall_color;
	color = mix(color, refracted_color, 1 - base_opacity);

	
	//color += wall_color;

	imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(color, 0.0));

*/
}
